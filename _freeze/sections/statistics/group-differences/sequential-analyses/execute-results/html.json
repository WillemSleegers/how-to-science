{
  "hash": "beb735d132b40dd5d8ad0ff2315a3dfb",
  "result": {
    "markdown": "---\ntitle: \"Sequential analyses\"\ntoc: true\ncode-tools: true\ncode-fold: show\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(MASS)\nlibrary(tidyverse)\nlibrary(viridis)\nlibrary(brms)\nlibrary(emmeans)\nlibrary(BayesFactor)\nlibrary(tidybayes)\n\n# Set the default ggplot theme\ntheme_set(theme_minimal())\n\n# Set seed\nset.seed(1)\n```\n:::\n\n\nThis section is about performing sequential analyses.\n\n## Bayesian\n\n### Two groups\n\nFor this scenario we simulate data from two different groups (say a control group and an experimental group).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the simulation parameters\nMs <- c(0, 0.25)\nSDs <- 1\nn <- 250\nlabels <- c(\"control\", \"experimental\")\n\n# Produce the variance-covariance matrix\nSigma <- matrix(\n  nrow = length(Ms), \n  ncol = length(Ms), \n  data = c(\n    SDs^2, 0,\n    0, SDs^2\n  )\n)\n\n# Simulate\nm <- mvrnorm(n = n, mu = Ms, Sigma = Sigma, empirical = TRUE)\n\n# Prepare data\ncolnames(m) <- labels\n\ndata <- as_tibble(m)\n\ndata <- pivot_longer(\n  data = data, \n  cols = everything(), \n  names_to = \"condition\", \n  values_to = \"DV\"\n)\n\ndata <- mutate(data, id = 1:n(), .before = condition)\n```\n:::\n\n\nThere are different Bayesian ways to analyze this data. One can focus on estimation or on Bayes factors.\n\n#### Estimation\n\nIf estimation is the goal, we run the model (or models) and obtain the posterior distribution of the estimates of interest. Below we run subsequent models with each model using more of the data.\n\n\n::: {.cell hash='sequential-analyses_cache/html/estimates-2-groups_a6e689dd5be45f0750f623f486e2ee3c'}\n\n```{.r .cell-code}\nns <- c(10, 20, 30, 40, 50, 75, 100, 150, 200, 250)\nresults <- tibble()\n\nfor (i in 1:length(ns)) {\n  # Get the sample size\n  n <- ns[i]\n  \n  # Draw a sample of size n\n  sample <- slice_head(data, n = n)\n  \n  # If this is the first iteration, run the full brms model\n  # Else update the model\n  if (i == 1) {\n    model <- brm(\n      formula = DV ~ 0 + Intercept + condition, \n      data = sample, \n      family = gaussian(), \n      prior = c(\n        set_prior(coef = \"Intercept\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"b\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"sigma\", prior = \"normal(1, 1)\")\n      )\n    )\n  } else {\n    model <- update(model, newdata = sample)\n  }\n  \n  # Get the posteriors of the model estimates\n  draws <- as_draws_df(model)\n  \n  # Add sample information\n  draws <- mutate(draws, step = i, n = n)\n  \n  # Add the draws to the results data frame\n  results <- bind_rows(\n    results, \n    draws\n  )\n}\n```\n:::\n\n\nNow we have the draws of the posterior distribution of the model estimates. We can plot these using the following code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_quantiles <- results %>%\n  filter(n == 250) %>%\n  pull(b_conditionexperimental) %>%\n  quantile(probs = c(.025, .975))\n\nggplot(results, aes(x = factor(n), y = b_conditionexperimental)) +\n  stat_halfeye() +\n  geom_hline(yintercept = final_quantiles, linetype = \"dashed\", alpha = .5) +\n  labs(x = \"Sample size per condition (n)\", y = \"\")\n```\n\n::: {.cell-output-display}\n![Horizontal lines show the 95% interval of the estimate from the largest sample.](sequential-analyses_files/figure-html/estimates-plot-2-groups-1.png){width=672}\n:::\n:::\n\n\n#### Bayes factors\n\nThis is still a work in progress. I have yet to figure out the best way to obtain Bayes factors using the `brms` package.\n\nBelow I use both `brms` and `BayesFactor` to calculate Bayes factors for the effect of condition across various sample sizes.\n\n\n::: {.cell hash='sequential-analyses_cache/html/sequential-analyses-2-groups_e6c81449195afd86a08751fffc94ec88'}\n\n```{.r .cell-code}\nns <- c(10, 20, 30, 40, 50, 75, 100, 150, 200, 250)\nresults <- tibble()\n\nfor (i in 1:length(ns)) {\n  # Get the sample size\n  n <- ns[i]\n  \n  # Draw a sample of size n\n  sample <- slice_head(data, n = n)\n  \n  # If this is the first iteration, run the full brms model\n  # Else update the model\n  if (i == 1) {\n    model <- brm(\n      formula = DV ~ 0 + Intercept + condition, \n      data = sample, \n      family = gaussian(), \n      prior = c(\n        set_prior(coef = \"Intercept\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"b\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"sigma\", prior = \"normal(1, 1)\")\n      ), \n      sample_prior = TRUE\n    )\n  } else {\n    model <- update(model, newdata = as.data.frame(sample))\n  }\n  \n  # Calculate the BF\n  BF_brms <- hypothesis(model, \"conditionexperimental = 0\")\n\n  # Also calculate the BF with the testBF() function from BayesFactor\n  BF_BF <- ttestBF(formula = DV ~ condition, data = sample)\n  \n  # Add the information to the bayes factors data frame\n  results <- bind_rows(\n    results, \n    tibble(\n      step = i,\n      n = n,\n      brms = BF_brms$hypothesis$Evid.Ratio,\n      BayesFactor = extractBF(BF_BF)$bf\n    )\n  )\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: data coerced from tibble to data frame\n\nWarning: data coerced from tibble to data frame\n\nWarning: data coerced from tibble to data frame\n\nWarning: data coerced from tibble to data frame\n\nWarning: data coerced from tibble to data frame\n\nWarning: data coerced from tibble to data frame\n\nWarning: data coerced from tibble to data frame\n\nWarning: data coerced from tibble to data frame\n\nWarning: data coerced from tibble to data frame\n\nWarning: data coerced from tibble to data frame\n```\n:::\n:::\n\n\nNext we plot the Bayes factors for each sample size and for each method of calculating the Bayes factor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults_long <- results %>%\n  mutate(BayesFactor = 1 / BayesFactor) %>%\n  pivot_longer(\n    cols = c(brms, BayesFactor), \n    names_to = \"method\", \n    values_to = \"BF\")\n\nggplot(\n    data = results_long, \n    mapping = aes(x = factor(n), y = BF, linetype = method, group = method)\n  ) +\n  geom_line() +\n  labs(\n    x = \"Sample size per condition (n)\", \n    y = expression(BF[\"10\"]), \n    linetype = \"Method\"\n  )\n```\n\n::: {.cell-output-display}\n![Bayes factors per sample size](sequential-analyses_files/figure-html/plot-bayes-factors-2-groups-1.png){width=672}\n:::\n:::\n\n\n### Four groups\n\nLet's simulate data for a scenario in which we have 4 different between-subjects conditions. The conditions differ from each by a small amount and for simplicity's sake each condition has a standard deviation of 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the simulation parameters\nMs <- c(0, 0.2, 0.4, 0.6)\nSDs <- 1\nn <- 250\nlabels <- c(\"A\", \"B\", \"C\", \"D\")\n\n# Produce the variance-covariance matrix\nSigma <- matrix(\n  nrow = length(Ms), \n  ncol = length(Ms), \n  data = c(\n    SDs^2, 0, 0, 0,\n    0, SDs^2, 0, 0,\n    0, 0, SDs^2, 0,\n    0, 0, 0, SDs^2\n  )\n)\n\n# Simulate\nm <- mvrnorm(n = n, mu = Ms, Sigma = Sigma, empirical = TRUE)\n\n# Prepare data\ncolnames(m) <- labels\n\ndata <- as_tibble(m)\n\ndata <- pivot_longer(\n  data = data, \n  cols = everything(), \n  names_to = \"condition\", \n  values_to = \"DV\"\n)\n\ndata <- mutate(data, id = 1:n(), .before = condition)\n```\n:::\n\n\n#### Estimation\n\nWith this data we can run multiple sequential models (like in the 2 groups scenario), except this time we calculate contrasts between all the levels of the condition factor. We again obtain the posteriors of these contrasts and store them so we can plot them afterwards.\n\n\n::: {.cell hash='sequential-analyses_cache/html/sequential-analyses-4-groups_cdbe9bbd6525f8c8f05ad268ba058437'}\n\n```{.r .cell-code}\nns <- c(10, 20, 30, 40, 50, 75, 100, 150, 200, 250)\nresults <- tibble()\n\nfor (i in 1:length(ns)) {\n  # Get the sample size\n  n <- ns[i]\n  \n  # Draw a sample of size n\n  sample <- slice_head(data, n = n)\n  \n  # If this is the first iteration, run the full brms model\n  # Else update the model\n  if (i == 1) {\n    model <- brm(\n      formula = DV ~ 0 + Intercept + condition, \n      data = sample, \n      family = gaussian(), \n      prior = c(\n        set_prior(coef = \"Intercept\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"b\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"sigma\", prior = \"normal(1, 1)\")\n      )\n    )\n  } else {\n    model <- update(model, newdata = sample)\n  }\n  \n  # Get the estimated marginal means\n  emmeans <- emmeans(model, specs = pairwise ~ condition)\n  contrasts <- emmeans$contrasts\n  \n  # Get draws of the posterior of each contrast\n  draws <- gather_emmeans_draws(contrasts)\n  \n  # Add sample information\n  draws <- mutate(draws, step = i, n = n)\n  \n  # Add the draws to the results data frame\n  results <- bind_rows(\n    results, \n    draws\n  )\n}\n```\n:::\n\n\nNow that we have a data frame that contains the posterior draws of each contrast, we can plot the posteriors as well as some summary statistics (e.g., the median, a 95% interval) for each contrast.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_quantiles <- results %>%\n  filter(n == 250) %>%\n  group_by(contrast) %>%\n  summarize(\n    final_lower = quantile(.value, .025),\n    final_upper = quantile(.value, .975)\n  ) %>%\n  pivot_longer(cols = -contrast, names_to = \"bound\", \"value\")\n\nggplot(results, aes(x = factor(n), y = .value)) +\n  stat_slabinterval() +\n  geom_hline(\n    mapping = aes(yintercept = value), \n    data = final_quantiles, \n    linetype = \"dashed\", \n    alpha = .5\n  ) +  \n  facet_wrap(~ contrast, ncol = 1, scales = \"free_y\") +\n  labs(x = \"Sample size per condition (n)\", y = \"Contrast estimate\") +\n  scale_color_viridis(option = \"mako\", discrete = TRUE)\n```\n\n::: {.cell-output-display}\n![Horizontal lines show the 95% interval of the estimate from the largest sample.](sequential-analyses_files/figure-html/plot-4-groups-1.png){width=672}\n:::\n:::\n\n\n#### Bayes factors\n\nBelow we run the same models but this time we calculate Bayes factors for each contrast using the `hypothesis()` function.\n\n\n::: {.cell hash='sequential-analyses_cache/html/bayes-factors-4-groups_914a78f8ebd2dcd54fdf87f3078bdced'}\n\n```{.r .cell-code}\nns <- c(10, 20, 30, 40, 50, 75, 100, 150, 200, 250)\nresults <- tibble()\n\nfor (i in 1:length(ns)) {\n  # Get the sample size\n  n <- ns[i]\n  \n  # Draw a sample of size n\n  sample <- slice_head(data, n = n)\n  \n  # If this is the first iteration, run the full brms model\n  # Else update the model\n  if (i == 1) {\n    model <- brm(\n      formula = DV ~ 0 + Intercept + condition, \n      data = sample, \n      family = gaussian(), \n      prior = c(\n        set_prior(coef = \"Intercept\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"b\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"sigma\", prior = \"normal(1, 1)\")\n      ), \n      sample_prior = TRUE\n    )\n  } else {\n    model <- update(model, newdata = sample)\n  }\n  \n  # Get the bayes factors for each contrast\n  BF_AB <- hypothesis(model, \"Intercept = conditionB\")\n  BF_AC <- hypothesis(model, \"Intercept = conditionC\")\n  BF_AD <- hypothesis(model, \"Intercept = conditionD\")\n  BF_BC <- hypothesis(model, \"conditionB = conditionC\")\n  BF_BD <- hypothesis(model, \"conditionB = conditionD\")\n  BF_CD <- hypothesis(model, \"conditionC = conditionD\")\n  \n  # Create a tibble with the Bayes factors and sample information\n  bayes_factors <- tibble(\n    i = i,\n    n = n,\n    `A - B` = BF_AB$hypothesis$Evid.Ratio,\n    `A - C` = BF_AC$hypothesis$Evid.Ratio,\n    `A - D` = BF_AD$hypothesis$Evid.Ratio,\n    `B - C` = BF_BC$hypothesis$Evid.Ratio,\n    `B - D` = BF_BD$hypothesis$Evid.Ratio,\n    `C - D` = BF_CD$hypothesis$Evid.Ratio\n  )\n\n  # Add the draws to the results data frame\n  results <- bind_rows(\n    results, \n    bayes_factors\n  )\n}\n```\n:::\n\n\nNext, we plot the Bayes factors over time, for each contrast.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults_long <- results %>%\n  pivot_longer(cols = -c(i, n), names_to = \"contrast\", values_to = \"BF\") %>%\n  mutate(BF = if_else(BF < 1, log(BF), BF))\n\nggplot(data = results_long, mapping = aes(x = factor(n), y = BF, group = 1)) +\n  geom_line() +\n  facet_wrap(~ contrast) + \n  labs(\n    x = \"Sample size per condition (n)\", \n    y = expression(BF[\"10\"]), \n    linetype = \"Method\"\n  )\n```\n\n::: {.cell-output-display}\n![](sequential-analyses_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}