{
  "hash": "17c467dcd1af177c963e199f0691546b",
  "result": {
    "markdown": "---\ntitle: \"Sequential analyses\"\ntoc: true\ncode-tools: true\ncode-fold: true\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(MASS)\nlibrary(tidyverse)\nlibrary(viridis)\nlibrary(brms)\nlibrary(emmeans)\nlibrary(BayesFactor)\nlibrary(tidybayes)\n\n# Set the default ggplot theme\ntheme_set(theme_minimal())\n\n# Set seed\nset.seed(1)\n```\n:::\n\n\nThis section is about performing sequential analyses.\n\n## Bayesian\n\n### Two groups\n\nFor this scenario we simulate data from two different groups (say a control group and an experimental group).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the simulation parameters\nMs <- c(0, 0.25)\nSDs <- 1\nn <- 250\nlabels <- c(\"control\", \"experimental\")\n\n# Produce the variance-covariance matrix\nSigma <- matrix(\n  nrow = length(Ms), \n  ncol = length(Ms), \n  data = c(\n    SDs^2, 0,\n    0, SDs^2\n  )\n)\n\n# Simulate\nm <- mvrnorm(n = n, mu = Ms, Sigma = Sigma, empirical = TRUE)\n\n# Prepare data\ncolnames(m) <- labels\n\ndata <- as_tibble(m)\n\ndata <- pivot_longer(\n  data = data, \n  cols = everything(), \n  names_to = \"condition\", \n  values_to = \"DV\"\n)\n\ndata <- mutate(data, id = 1:n(), .before = condition)\n```\n:::\n\n\nThere are different Bayesian ways to analyze this data. One can focus on estimation or on Bayes factors.\n\n#### Estimation\n\nIf estimation is the goal, we run the model (or models) and obtain the posterior distribution of the estimates of interest. Below we run subsequent models with each model using more of the data.\n\n\n::: {.cell hash='sequential-analyses_cache/html/estimates-2-groups_a6e689dd5be45f0750f623f486e2ee3c'}\n\n```{.r .cell-code}\nns <- c(10, 20, 30, 40, 50, 75, 100, 150, 200, 250)\nresults <- tibble()\n\nfor (i in 1:length(ns)) {\n  # Get the sample size\n  n <- ns[i]\n  \n  # Draw a sample of size n\n  sample <- slice_head(data, n = n)\n  \n  # If this is the first iteration, run the full brms model\n  # Else update the model\n  if (i == 1) {\n    model <- brm(\n      formula = DV ~ 0 + Intercept + condition, \n      data = sample, \n      family = gaussian(), \n      prior = c(\n        set_prior(coef = \"Intercept\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"b\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"sigma\", prior = \"normal(1, 1)\")\n      )\n    )\n  } else {\n    model <- update(model, newdata = sample)\n  }\n  \n  # Get the posteriors of the model estimates\n  draws <- as_draws_df(model)\n  \n  # Add sample information\n  draws <- mutate(draws, step = i, n = n)\n  \n  # Add the draws to the results data frame\n  results <- bind_rows(\n    results, \n    draws\n  )\n}\n```\n:::\n\n\nNow we have the draws of the posterior distribution of the model estimates. We can plot these using the following code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_quantiles <- results %>%\n  filter(n == 250) %>%\n  pull(b_conditionexperimental) %>%\n  quantile(probs = c(.025, .975))\n\nggplot(results, aes(x = factor(n), y = b_conditionexperimental)) +\n  stat_halfeye() +\n  geom_hline(yintercept = final_quantiles, linetype = \"dashed\", alpha = .5) +\n  labs(x = \"Sample size per condition (n)\", y = \"\")\n```\n\n::: {.cell-output-display}\n![Horizontal lines show the 95% interval of the estimate from the largest sample.](sequential-analyses_files/figure-html/estimates-plot-2-groups-1.png){width=672}\n:::\n:::\n\n\n### Bayes factors\n\nThis is still a work in progress. I have yet to figure out the best way to obtain Bayes factors using the `brms` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_step <- 50\nresults <- tibble()\n\nfor (i in 1:(n / n_step)) {\n  # Draw a sample\n  sample <- slice_head(data, n = i * n_step)\n  \n  # Run the brm model\n  model <- brm(\n    formula = DV ~ 0 + Intercept + condition, \n    data = sample, \n    family = gaussian(), \n    prior = c(\n      set_prior(coef = \"Intercept\", prior = \"normal(0, 1)\"),\n      set_prior(class = \"b\", prior = \"student_t(1, 0, 1)\"),\n      #set_prior(class = \"sigma\", prior = \"normal(1, 1)\"),\n      set_prior(\"\", \"sigma\") + \n        set_prior(\"target += log(1 / sigma)\", check = FALSE)\n    ), \n    sample_prior = TRUE\n  )\n  \n  # Calculate the BF of a contrast\n  BF_brms <- hypothesis(model, \"conditionexperimental = 0\")\n\n  BF_BF <- ttestBF(formula = DV ~ condition, data = sample, rscale = \"wide\")\n  \n  # Add the information to the bayes factors data frame\n  results <- bind_rows(\n    bayes_factors, \n    tibble(\n      step = i,\n      n = i * n_step,\n      BF_brms = BF_brms$hypothesis$Evid.Ratio,\n      BF_BF = extractBF(BF_BF)$bf\n    )\n  )\n}\n```\n:::\n\n\n### Four groups\n\nLet's simulate data for a scenario in which we have 4 different between-subjects conditions. The conditions differ from each by a small amount and for simplicity's sake each condition has a standard deviation of 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the simulation parameters\nMs <- c(0, 0.2, 0.4, 0.6)\nSDs <- 1\nn <- 250\nlabels <- c(\"A\", \"B\", \"C\", \"D\")\n\n# Produce the variance-covariance matrix\nSigma <- matrix(\n  nrow = length(Ms), \n  ncol = length(Ms), \n  data = c(\n    SDs^2, 0, 0, 0,\n    0, SDs^2, 0, 0,\n    0, 0, SDs^2, 0,\n    0, 0, 0, SDs^2\n  )\n)\n\n# Simulate\nm <- mvrnorm(n = n, mu = Ms, Sigma = Sigma, empirical = TRUE)\n\n# Prepare data\ncolnames(m) <- labels\n\ndata <- as_tibble(m)\n\ndata <- pivot_longer(\n  data = data, \n  cols = everything(), \n  names_to = \"condition\", \n  values_to = \"DV\"\n)\n\ndata <- mutate(data, id = 1:n(), .before = condition)\n```\n:::\n\n\nWith this data we can run multiple sequential models (like in the 2 groups scenario), except this time we calculate contrasts between all the levels of the condition factor. We again obtain the posteriors of these contrasts and store them so we can plot them afterwards.\n\n\n::: {.cell hash='sequential-analyses_cache/html/sequential-analyses-4-groups_cdbe9bbd6525f8c8f05ad268ba058437'}\n\n```{.r .cell-code}\nns <- c(10, 20, 30, 40, 50, 75, 100, 150, 200, 250)\nresults <- tibble()\n\nfor (i in 1:length(ns)) {\n  # Get the sample size\n  n <- ns[i]\n  \n  # Draw a sample of size n\n  sample <- slice_head(data, n = n)\n  \n  # If this is the first iteration, run the full brms model\n  # Else update the model\n  if (i == 1) {\n    model <- brm(\n      formula = DV ~ 0 + Intercept + condition, \n      data = sample, \n      family = gaussian(), \n      prior = c(\n        set_prior(coef = \"Intercept\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"b\", prior = \"normal(0, 1)\"),\n        set_prior(class = \"sigma\", prior = \"normal(1, 1)\")\n      )\n    )\n  } else {\n    model <- update(model, newdata = sample)\n  }\n  \n  # Get the estimated marginal means\n  emmeans <- emmeans(model, specs = pairwise ~ condition)\n  contrasts <- emmeans$contrasts\n  \n  # Get draws of the posterior of each contrast\n  draws <- gather_emmeans_draws(contrasts)\n  \n  # Add sample information\n  draws <- mutate(draws, step = i, n = n)\n  \n  # Add the draws to the results data frame\n  results <- bind_rows(\n    results, \n    draws\n  )\n}\n```\n:::\n\n\nNow that we have a data frame that contains the posterior draws of each contrast, we can plot the posteriors as well as some summary statistics (e.g., the median, a 95% interval) for each contrast.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_quantiles <- results %>%\n  filter(n == 250) %>%\n  group_by(contrast) %>%\n  summarize(\n    final_lower = quantile(.value, .025),\n    final_upper = quantile(.value, .975)\n  ) %>%\n  pivot_longer(cols = -contrast, names_to = \"bound\", \"value\")\n\nggplot(results, aes(x = factor(n), y = .value)) +\n  stat_slabinterval() +\n  geom_hline(\n    mapping = aes(yintercept = value), \n    data = final_quantiles, \n    linetype = \"dashed\", \n    alpha = .5\n  ) +  \n  facet_wrap(~ contrast, ncol = 1, scales = \"free_y\") +\n  labs(x = \"Sample size per condition (n)\", y = \"Contrast estimate\") +\n  scale_color_viridis(option = \"mako\", discrete = TRUE)\n```\n\n::: {.cell-output-display}\n![Sequential analysis](sequential-analyses_files/figure-html/plot-4-groups-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}