{
  "hash": "b093e70131e11f591113b677a7294197",
  "result": {
    "markdown": "---\ntitle: \"Pairwise comparisons\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(MASS)\nlibrary(tidyverse)\nlibrary(viridis)\nlibrary(brms)\nlibrary(emmeans)\n\n# Set the default ggplot theme\ntheme_set(theme_minimal())\n```\n:::\n\n\nThis section is about different statistical techniques to analyze group differences.\n\n## Bayesian\n\n### Pairwise comparisons\n\nIn this scenario we simulate data from a study with 5 different groups. The conditions differ from each by a small amount and for simplicity's sake each condition has a standard deviation of 1. The sample size per condition is 250.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the simulation parameters\nMs <- c(0, 0.1, 0.2, 0.3, 0.4)\nSDs <- 1\nn <- 250\n\n# Produce the variance-covariance matrix\nSigma <- matrix(\n  nrow = length(Ms), \n  ncol = length(Ms), \n  data = c(\n    SDs^2, 0, 0, 0, 0,\n    0, SDs^2, 0, 0, 0,\n    0, 0, SDs^2, 0, 0,\n    0, 0, 0, SDs^2, 0,\n    0, 0, 0, 0, SDs^2\n  )\n)\n\n# Simulate the values\nm <- mvrnorm(n = n, mu = Ms, Sigma = Sigma, empirical = TRUE)\n\n# Prepare the data by converting it to a data frame and making it tidy\ncolnames(m) <- c(\"A\", \"B\", \"C\", \"D\", \"E\")\n\ndata <- as_tibble(m)\n\ndata <- pivot_longer(\n  data = data, \n  cols = everything(), \n  names_to = \"condition\", \n  values_to = \"DV\"\n)\n\ndata <- mutate(data, id = 1:n(), .before = condition)\n```\n:::\n\n\nTo perform the pairwise comparisons we first fit a model with `brms`. If we also want to calculate Bayes factors, we need to set a prior for the intercept. For technical reasons, this needs to be done by explicitly including the intercept in the formula. After that we need to set 3 priors: 1 for the intercept, 1 for all the other coefficients, and one for sigma. We'll set some weak priors because we don't have any additional information about this simulated data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel <- brm(\n  formula = DV ~ 0 + Intercept + condition, \n  data = data, \n  family = gaussian(), \n  prior = c(\n    set_prior(coef = \"Intercept\", prior = \"normal(0, 1)\"),\n    set_prior(class = \"b\", prior = \"normal(0, 1)\"),\n    set_prior(class = \"sigma\", prior = \"normal(1, 1)\")\n  ), \n  sample_prior = TRUE\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCompiling Stan program...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nStart sampling\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nSAMPLING FOR MODEL '26506c9e129ffc36bd1658ecb9d890c1' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 2.2e-05 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.22 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 1: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 0.064438 seconds (Warm-up)\nChain 1:                0.061852 seconds (Sampling)\nChain 1:                0.12629 seconds (Total)\nChain 1: \n\nSAMPLING FOR MODEL '26506c9e129ffc36bd1658ecb9d890c1' NOW (CHAIN 2).\nChain 2: \nChain 2: Gradient evaluation took 9e-06 seconds\nChain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.09 seconds.\nChain 2: Adjust your expectations accordingly!\nChain 2: \nChain 2: \nChain 2: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 2: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 2: \nChain 2:  Elapsed Time: 0.066317 seconds (Warm-up)\nChain 2:                0.059674 seconds (Sampling)\nChain 2:                0.125991 seconds (Total)\nChain 2: \n\nSAMPLING FOR MODEL '26506c9e129ffc36bd1658ecb9d890c1' NOW (CHAIN 3).\nChain 3: \nChain 3: Gradient evaluation took 1.4e-05 seconds\nChain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.14 seconds.\nChain 3: Adjust your expectations accordingly!\nChain 3: \nChain 3: \nChain 3: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 3: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 3: \nChain 3:  Elapsed Time: 0.065105 seconds (Warm-up)\nChain 3:                0.063011 seconds (Sampling)\nChain 3:                0.128116 seconds (Total)\nChain 3: \n\nSAMPLING FOR MODEL '26506c9e129ffc36bd1658ecb9d890c1' NOW (CHAIN 4).\nChain 4: \nChain 4: Gradient evaluation took 1.6e-05 seconds\nChain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.16 seconds.\nChain 4: Adjust your expectations accordingly!\nChain 4: \nChain 4: \nChain 4: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 4: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 4: \nChain 4:  Elapsed Time: 0.067285 seconds (Warm-up)\nChain 4:                0.06156 seconds (Sampling)\nChain 4:                0.128845 seconds (Total)\nChain 4: \n```\n:::\n\n```{.r .cell-code}\nmodel\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: DV ~ 0 + Intercept + condition \n   Data: data (Number of observations: 1250) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nPopulation-Level Effects: \n           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept      0.00      0.06    -0.12     0.12 1.01      934     1387\nconditionB     0.10      0.09    -0.08     0.27 1.00     1308     2112\nconditionC     0.20      0.09     0.02     0.37 1.00     1336     1957\nconditionD     0.30      0.09     0.12     0.47 1.00     1230     2048\nconditionE     0.39      0.09     0.22     0.57 1.00     1236     1816\n\nFamily Specific Parameters: \n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     1.00      0.02     0.96     1.04 1.00     3566     2814\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n:::\n\n\nThe estimates range, as expected, from 0 for the intercept to 0.40 for condition E.\n\nIf we want pairwise comparisons, we can use the `emmeans` package to obtain them. We use the `emmeans()` function and set the `specs` argument to `pairwise ~ condition`. `pairwise` is a reserved term to use for exactly this purpose. The result is an object that contains estimated marginal means and contrasts. Since we're interested in the pairwise comparisons we only print the contrasts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemmeans <- emmeans(model, specs = pairwise ~ condition)\n\ncontrasts <- emmeans$contrasts\ncontrasts\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n contrast estimate lower.HPD upper.HPD\n A - B     -0.0950    -0.266    0.0773\n A - C     -0.1953    -0.369   -0.0213\n A - D     -0.2990    -0.479   -0.1340\n A - E     -0.3937    -0.572   -0.2223\n B - C     -0.0995    -0.282    0.0668\n B - D     -0.1999    -0.374   -0.0278\n B - E     -0.2985    -0.478   -0.1220\n C - D     -0.1009    -0.275    0.0825\n C - E     -0.1968    -0.366   -0.0232\n D - E     -0.0952    -0.270    0.0870\n\nPoint estimate displayed: median \nHPD interval probability: 0.95 \n```\n:::\n:::\n\n\nThis gives us the estimates as well as lower and upper bounds of a highest probability density intervals. We can also plot them using the following code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrasts <- as_tibble(contrasts)\n\nggplot(contrasts, aes(x = contrast, y = estimate)) +\n  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD)) +\n  labs(x = \"Contrast\", y = \"Estimate with 95% HPD\")\n```\n\n::: {.cell-output-display}\n![Pairwise comparisons via `emmeans`](pairwise-comparisons_files/figure-html/pairwise-comparisons-plot-1.png){width=672}\n:::\n:::\n\n\nAlternatively, we can also calculate specific contrasts using the `hypothesis()` function from `brms`. The added value of calculating contrasts this way is that it also provides us with a Bayes factor if we set priors for all parts of the model.\n\nFor example, we can get the contrast between condition A and B by subtracting the Intercept from the condition B coefficient. We can then get an evidence ratio for the test that this value is larger than 0. This value is simply the ratio of the number of samples larger (or smaller) than a value to the number of samples smaller (or larger) than the value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrast_A_B <- hypothesis(model, \"conditionB - Intercept > 0\")\ncontrast_A_B\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHypothesis Tests for class b:\n                Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio\n1 (conditionB-Inter... > 0     0.09      0.14    -0.14     0.32       2.95\n  Post.Prob Star\n1      0.75     \n---\n'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses.\n'*': For one-sided hypotheses, the posterior probability exceeds 95%;\nfor two-sided hypotheses, the value tested against lies outside the 95%-CI.\nPosterior probabilities of point hypotheses assume equal prior probabilities.\n```\n:::\n\n```{.r .cell-code}\n# sum(contrast_A_B$samples$H1 > 0) / sum(contrast_A_B$samples$H1 < 0)\n```\n:::\n\n\nThis gives us an estimate of 0.1 (as expected) and an evidence ratio of 2.9486673.\n\nWe can also test whether this contrast is equal to 0. This is a Bayes factor computed via the Savage-Dickey density ratio method. That is, the posterior density at a point of interest is divided by the prior density at the same point.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrast_A_B_null <- hypothesis(model, \"conditionB - Intercept = 0\")\ncontrast_A_B_null\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHypothesis Tests for class b:\n                Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio\n1 (conditionB-Inter... = 0     0.09      0.14    -0.18     0.37       8.25\n  Post.Prob Star\n1      0.89     \n---\n'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses.\n'*': For one-sided hypotheses, the posterior probability exceeds 95%;\nfor two-sided hypotheses, the value tested against lies outside the 95%-CI.\nPosterior probabilities of point hypotheses assume equal prior probabilities.\n```\n:::\n:::\n\n\nThis gives us a Bayes factor of 8.250272.\n\nAlternatively, we can compare another contrast, say, D vs. B. We can get this contrast by subtracting the coefficient for condition B from the coefficient for condition D.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrast_D_B <- hypothesis(model, \"conditionD - conditionB > 0\")\ncontrast_D_B\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHypothesis Tests for class b:\n                Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio\n1 (conditionD-condi... > 0      0.2      0.09     0.06     0.34      94.24\n  Post.Prob Star\n1      0.99    *\n---\n'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses.\n'*': For one-sided hypotheses, the posterior probability exceeds 95%;\nfor two-sided hypotheses, the value tested against lies outside the 95%-CI.\nPosterior probabilities of point hypotheses assume equal prior probabilities.\n```\n:::\n:::\n\n\nAs expected, we see an estimate of 0.2 (0.4 - 0.2). We also see an evidence ratio of 94.2380952 for the hypothesis that this is larger than 0.\n",
    "supporting": [
      "pairwise-comparisons_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}